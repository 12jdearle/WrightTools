\documentclass[11pt]{article}
\setlength\parindent{0pt}
\setlength{\parskip}{1em}
\usepackage{amssymb, amsmath, graphics, epsfig, graphicx, epstopdf}
\usepackage{xpatch}
\usepackage[letterpaper, portrait, margin=1in]{geometry}
\usepackage{setspace}

%font
\renewcommand{\familydefault}{\sfdefault}
\usepackage[cm]{sfmath}

%hyperref
\usepackage[colorlinks=true, linkcolor=black, urlcolor=blue, citecolor=black, anchorcolor=black]{hyperref}
\usepackage[all]{hypcap} % helps hyperref work properly

%-todo
\usepackage{color}
\usepackage[colorinlistoftodos]{todonotes}

%\usepackage{minted}

%bibliography
\usepackage[backend=biber, natbib=true, url=false, sorting=none, maxbibnames=99]{biblatex}
\bibliography{database}
\renewcommand{\thesection}{\arabic{section}}

\begin{document}

%title
\begin{flushleft}
	{\Huge \textbf{WrightTools documentation}}
\end{flushleft}

%table of contents
{\let\newpage\relax\begin{spacing}{0.1}\tableofcontents\end{spacing}}
\pagebreak
\listoftodos
\pagebreak

\section{Introduction}

WrightTools is a python package for processing and viewing data. WrightTools is designed to be used in python scripts. For the purpose of this document, we will assume that WrightTools is imported with the alias \texttt{wt}: \texttt{import WrightTools as wt}.

\todo[inline]{include overview of package structure}

As a living software package with evolving capabilities, detailed documentation of WrightTools here is neither easy nor useful. For specific usage notes look to the \href{https://www.python.org/dev/peps/pep-0257/#what-is-a-docstring}{docstrings} in WrightTools itself. This document is meant to provide a coarse-grained description of the entire package. It also describes design philosophies and best-practices when using WrightTools.

\pagebreak
\section{Data}

The \texttt{Data} class is an incredibly general class capable of representing any rectangular dataset. It fills two important roles within WrightTools:
\begin{enumerate}
	\item \texttt{Data} defines a single format to represent the results almost any measurement or simulation.
	\item \texttt{Data} provides a suite of methods for data manipulation.
\end{enumerate}
Almost every capability of WrightTools relies upon \texttt{Data} to some extent. \texttt{Data} can be thought of as the glue that holds the entire Wright group software stack together.

\begin{figure}[h]\label{fig:data overview}
	\begin{centering}
		\includegraphics[scale=0.5]{"graphml/data overview"}
		\caption{\texttt{Data} is the gateway to WrightTools.}
	\end{centering}
\end{figure}

Figure \ref{fig:data overview} represents WrightTools accepting data from a variety of sources and formats. \texttt{Data} objects are typically not created directly through \texttt{Data.\_\_init\_\_} like most python classes. Instead, \texttt{Data} objects are created from files through a series of custom `\texttt{from\_file}' methods found in the \texttt{data.py} module. By creating separate methods, WrightTools can allow for easy \texttt{Data} creation from many different file formats. More details on \texttt{Data} creation can be found in Section \ref{section:instantiation}. Once created, regardless of origin, the \texttt{Data} object is ready to be used by other classes in WrightTools, such as artists and \texttt{Fitter}.

\subsection{Structure \& Properties}

The heart of \texttt{Data} are the \href{https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html}{\texttt{numpy.ndarray}}s that contain the numbers themselves. Everything else is, in some sense, \textit{decoration}. The arrays are not attributes of \texttt{Data} itself, rather they are attributes of the closely related \texttt{wt.data.Axis} and \texttt{wt.data.Channel} classes. \texttt{Data} contains lists of \texttt{Axis}es and \texttt{Channel}s. To understand the basic structure of \texttt{Data}, then, one must first understand the structure of \texttt{Axis} and \texttt{Channel}.

Axes are the \textit{coordinates} of points in a dataset. Since all datasets are rectangular, axes are always one-dimensional. \texttt{wt.data.Axis} is the class that contains these coordinates and their properties. Table \ref{tab:axis properties} highlights the most important attributes and methods of \texttt{Axis}.
\begin{table}\label{tab:axis properties}	
	\begin{center}
		\begin{tabular}{r | l}
			\texttt{points} & \texttt{numpy.ndarray} of axis coordinates \\ 
			\texttt{name} & the `python-friendly' name \\ 
			\texttt{units} & the current units of the axis \\ 
			\texttt{convert} & method to convert axis units \\
			\texttt{label\_seed} & list of subscript strings for label \\
			\texttt{get\_label} & method to get formated label string
		\end{tabular}
	\end{center}
	\caption{The most important attributes and methods of the \texttt{wt.data.Axis} class.}
\end{table}
Axes may be regular or differential.

Channels are the values in a dataset. A \texttt{Data} instance may contain many channels, since each coordinate may have multiple recorded values e.g. signal, pyro1, and pyro2. \texttt{wt.data.Channel} is the class that contains these values and their properties. Table \ref{tab:channel properties} highlights the most important attributes and methods of \texttt{Channel}.
\begin{table}\label{tab:channel properties}
	\begin{center}
		\begin{tabular}{r | l}
			\texttt{values} & \texttt{numpy.ndarray} of dataset values \\ 
			\texttt{name} & the `python-friendly' name \\
			\texttt{invert} & method to invert values \\
			\texttt{zmin} & maximum \\
			\texttt{zmax} & minimum \\
			\texttt{znull} & null value \\
			\texttt{signed} & \texttt{bool} flag for signed data \\
			\texttt{normalize} & method to enforce scaling such that znull to zmax spans 0-1 \\
			\texttt{clip} & method to remove values outside of a certain range
		\end{tabular}
	\end{center}
	\caption{The most important attributes and methods of the \texttt{wt.data.Channel} class.}
\end{table}
The \texttt{signed} flag of \texttt{Channel} changes how other parts of WrightTools interact with the dataset. For example, an artist may choose to use a different colorbar if a dataset is signed. Allowing the `null value' of a dataset to be non-zero is an important feature of WrightTools. When possible, developers should anticipate non-zero \texttt{znull}s. Also note that \texttt{Channel.values} may contain \texttt{NaN}s. When manipulating the \texttt{values} array directly, it is best practices to use \texttt{Channel.\_update()} to force the flags and attributes of the object to correspond to the new values.

The \texttt{Data} object has two primary attributes: \texttt{axes}, a list of \texttt{Axis} objects, and \texttt{channels}, a list of \texttt{Channel} objects. \texttt{axes} contains exactly one \texttt{Axis} object for each dimension of the dataset. The order of \texttt{axes} matters, so that the nth member of \texttt{axes} contains the coordinates along the nth dimension of the dataset. The order of \texttt{channels} is arbitrary. It is typical for code in WrightTools to assume that the most important channel is first. In addition to members of lists, \texttt{Data} dynamically sets the \texttt{Axis} and \texttt{Channel} objects it contains as attributes of itself according to the names of those objects. This means that users have two choices when accessing axes and channels. For example, consider an axis \texttt{w1} located in dimension \texttt{0}. To access this axis' points, one may go via the list: \texttt{data.axes[0].points} or directly \texttt{data.w1.points}. A consequence of this feature is that \texttt{Axis} and \texttt{Channel} object names must be unique to the \texttt{Data} container. Beyond the two main lists, \texttt{Data} is primarily a long series of methods that operate on the dataset it contains. Table \ref{tab:data properties} highlights the `structural' attributes and methods of \texttt{Data}.
\begin{table}\label{tab:data properties}
	\begin{center}
		\begin{tabular}{r | l}
			\texttt{axes} & list of the contained \texttt{Axis} objects \\ 
			\texttt{channels} & list of the contained \texttt{Channel} objects \\
			\texttt{name} & the `python-friendly' name \\
			\texttt{chop} & powerful method for accessing lower-dimensional slice(s) \\
			\texttt{split} & method for splitting dataset at axis coordinate(s) \\
			\texttt{transpose} & method to change order of dimensions in dataset \\
			\texttt{copy} & method for getting deep copy \\
			\texttt{flip} & method for flipping order of coordinates within an axis \\
			\texttt{map\_axis} & method to map dataset onto new coordinates using interpolation \\
			\texttt{remove\_channel} & method to remove a channel \\
			\texttt{bring\_to\_front} & method to bring a channel to the front of \texttt{channels} \\
		\end{tabular}
	\end{center}
	\caption{The most important attributes and methods of the \texttt{wt.data.Data} class.}
\end{table}
There are many other attributes and methods of \texttt{Data}, most of which will be talked about in specific context elsewhere in this document.

\subsection{Instantiation}\label{section:instantiation}

The creation of a \texttt{Data} object from a raw file or other source may be a very different process depending on the dataset's origin. It is not reasonable to handle all details for all datastreams directly in \texttt{wt.data.Data.\_\_init\_\_}. Instead, \texttt{Data} objects are typically created using a \texttt{wt.data.from\_X} method. These methods accept any relevant parameters and return an instantiated \texttt{Data} object. \texttt{wt.data.from\_X} methods have been written for all of the commonly-used file formats in the Wright Group.

The details of importing from each source are unique, but there is a common theme:
\begin{enumerate}
	\item Recognize axes of scan
	\item Grid raw data onto scan axes
	\item Assemble \texttt{Data} instance
\end{enumerate} 

\subsubsection{Direct}

Direct instantiation of \texttt{Data} is easy, if you start with your dataset as regular arrays in python. 

\subsubsection{PyCMDS}

PyCMDS was developed from the start to work well with WrightTools. One of the most important products of that design is the rich system of headers that PyCMDS \texttt{.data} files posses, making the step of scan axis recognition trivial...

\subsubsection{COLORS and Kent}

\subsection{Manipulation}

chop, slice, join etc

\subsection{Scaling \& Normalization}

\subsubsection{dOD}

Transient absorption data is most usefully viewed in $d$OD units, but it is naturally recorded in $dI$ and $I$. The \texttt{dOD} method of \texttt{Data} does the necessary transformation. Conveniently, absolute OD cancels out such that $dI$ and $I$ are all that is needed to calculate dOD.

\begin{eqnarray}
	d\mathrm{OD} &=& -\log_{10}\left(\frac{I+dI}{I_0}\right) +  \log_{10}\left(\frac{I}{I_0}\right)\\
	&=& -\left(\log_{10}(I+d\mathrm{I})-\log_{10}(I_0)\right)+\left(\log_{10}(I)-\log_{10}(I_0)\right) \\
	&=& \log_{10}(I)-\log_{10}(I+dI) \\
	&=& -\log_{10}\left(\frac{I+dI}{I}\right)
\end{eqnarray}

Here $I_0$ is the probe intensity before the sample, $I$ is the probe intensity after the sample without pump, and $dI$ is the change in probe intensity caused by the pump.

There are a few instrumental considerations when measuring $I$ and $dI$:
\begin{enumerate}
	\item Typically it is most convenient to measure $I$ as the average probe intensity for all shots (with and without pump). This is a good approximation as long as $dI<<I$.
	\item $dI$ is defined as the total change in intensity. Boxcar averagers in active background subtraction mode return \textit{one half} of the total change. The \texttt{dOD} method has a \texttt{kwarg} `\texttt{method}' that can be used to appropriately take this factor of two into account. PyCMDS takes this factor into account in shots processing.
\end{enumerate}






\pagebreak
\section{Artists}

The artists module contains a variety of tools, all related to visualizing data. It contains two workhorse classes: \texttt{wt.artists.mpl\_2D} and \texttt{wt.artists.mpl\_1D}, which generate general visualizations of 2D and 1D slices of data objects. It also contains a series of specialized artists.

\subsection{Colormaps}

\begin{figure} \label{fig:colormaps}
	\begin{centering}
		\includegraphics[width=5in]{colormaps.png}
		\caption{WrightTools colormaps as of version 1.5.0.}
	\end{centering}
\end{figure}

\begin{figure} \label{fig:colormap components}
	\begin{centering}
		\includegraphics[width=5in]{colormap_components.png}
		\caption{WrightTools default colormap RGB components.}
	\end{centering}
\end{figure}

Figure \ref{fig:colormap components} shows the RGB components of WrightTools' default colormap for single-signed data. This colormap is a custom implementation of the `cubehelix' color scheme developed by \textcite{Green2011}. The parameters were chosen to keep the colormap perceptual while closely matching the traditional Wright group colormap (\texttt{wt.artists.colormaps['wright']}). The colormap is slightly distorted in luminosity for aesthetic purposes.

\pagebreak
\section{Fit} 
	
	The fit module provides tools for fitting data. It contains a series of \texttt{Function} objects, which handle the actual minimization routines given a dataset. These can be used outside of WrightTools. For example, given \texttt{xi} and \texttt{yi} as 1D arrays:
	
	%\begin{minted}[ frame=lines, framesep=2mm, %baselinestretch=1.2, fontsize=\footnotesize, linenos] %{python}
	%function = wt.fit.Gaussian()  # create an instance of %Gaussian class
	%center, width, amplitude, baseline = function.fit(yi, xi)  %# do fit on your arrays
	%\end{minted}
	
	The fit module also contains a class made to send \texttt{data} through fitting operations: \texttt{wt.fit.Fitter}. Like in WrightTools artists, \texttt{Fitter} will take high dimensionality data and iterate over the dimensions higher than the ones being addressed.

\pagebreak
\section{Tuning}

The tuning module provides tools for interacting with for optical parametric amplifier (OPA) tuning curves. It defines a main class, \texttt{wt.tuning.curve.Curve}, which is capable of representing tuning curves from multiple kinds of OPA. The tuning module also contains a series of modules and methods that accomplish certain specialized data processing tasks related to OPA tuning.

\subsection{OPA Tuning Curves}

OPA tuning curves are arrays of motor positions corresponding to parametric output colors. WrightTools offers an object-type to represent and manipulate OPA tuning curve arrays.

\subsubsection{The Curve Class}

The \texttt{Curve} class is made to contain OPA tuning curve data for any kind of OPA. By representing curves from different OPA hardware in the same format, WrightTools consolidates common tuning curve manipulations. \texttt{Curve} is a lot like the \texttt{wt.data.Data} class:

\begin{enumerate}
	\item \texttt{Curve} is a container for other objects - in this case instances of the \texttt{wt.tuning.curve.Motor} class. 
	\item \texttt{Curve} objects are not meant to be instantiated directly. Instead they are returned by the `from' methods of the \texttt{wt.tuning.curve} module. 
\end{enumerate}

OPA tuning curves are often defined in `stages' where each stage accomplishes an additional parametric conversion on the light supplied by the previous stage. For example, a `base' OPA may supply pump and signal to a mixing crystal to be added together again to sum frequency signal. The sum frequency may then go on again to be doubled in another mixing process and so on. Each stage has its own tuning curve. To accommodate this structure \texttt{Curve} objects may be `nested' inside of themselves, such that each curve refers to its own attribute \texttt{curve.subcurve} to get the motor positions for the previous stage.

Curve objects have some useful methods for visualizing and working with tuning curve arrays. \todo{discuss map axes, plot, save, offset}

\todo[inline]{discuss interpolation}

Curve objects also serve as a convenient backend for OPA hardware in PyCMDS...

\texttt{curve.get\_motor\_positions} returns a numpy array with shape (motor count, color count)...


\subsection{TOPAS-C Motortune Processing}

Traveling-wave Optical Parametric Amplifier of White-light Continuum (TOPAS-C) is an automated OPA made by Light Conversion. In TOPAS-C, four motors are used in the creation of signal and idler. These can be divided into subcategories of `preamp' and `poweramp', each containing two motors. After signal and idler are generated, additional motorized crystals, `mixers', can be used to upconvert or downconvert the base colors. This allows TOPAS-C to achieve a huge dynamic range of output colors, from ultraviolet to mid-infrared.z

WrightTools contains a processing method for each parametric process used in the Wright group TOPAS-C. Each of these methods is described in this section.

\subsubsection{Signal Preamp}

In the TOPAS-C preamp white light is mixed non-colinearly with a small amount of pump to generate signal and idler. The signal output is angularly isolated and sent on to seed parametric output in a second crystal (the poweramp). 

Two motors are used to control preamp output: Crystal 1 (C1) controls the angle of the mixing crystal and Delay 1 (D1) controls the delay between white light and pump in the mixing crystal. White light in TOPAS-C is intentionally chirped, so that D1 influences color by choosing a portion of the white light spectrum to overlap with pump. Since phase matching controlled by C1 angle also influences preamp output color, both motors influence color and intensity of preamp output. The measured dependence of output intensity and color on C1 and D1 positions is shown in Figure \ref{fig:TOPAS amplitude and center}.

\begin{figure}
	\begin{centering}
		\includegraphics[width=7in]{TOPAS_tuning_examples/amplitude_and_center.png}
		\caption{OPA output intensity and color as a function of C1 and D1. Measured on OPA1 (serial number 10743) 2016/01/13. Plotted pixels correspond directly to actual measured OPA outputs. The OPA output was measured using an array detector and fit to a single Gaussian lineshape. Grey pixels gave bad fits and were therefore filtered out. A small number of fits within the body of good data did fail and were filled in using bi-cubic interpolation. Data taken with PyCMDS MOTORTUNE module.}
	\end{centering}
	\label{fig:TOPAS amplitude and center}
\end{figure}

The correlation between motor position, color, and intensity present special challenges to tuning TOPAS-C preamp...

To address this, WrightTools groups contours of constant color together and fits each contour to a Gaussian. This is shown in Figure \ref{fig:TOPAS contour fit}.

\begin{figure}
	\begin{centering}
		\includegraphics[width=6in]{preamp_motortune.png}
		\caption{}
	\end{centering}
	\label{fig:TOPAS contour fit}
\end{figure}

In the final step, WrightTools passes the resulting tune points through a univariate spline to ensure smoothness and attempt to extend the curve outwards. In principle a polynomial fit could be used, but in practice splines are more robust to poor behavior at the edges of the tuning curve, where polynomials may oscillate wildly (Runge's phenomenon).

\begin{figure}
	\begin{centering}
		\includegraphics[width=6in]{preamp_motortune.png}
		\caption{}
	\end{centering}
	\label{fig:TOPAS preamp motortune}
\end{figure}


\subsubsection{Signal Poweramp}

\subsection{OPA800 Motortune Processing}

OPA800 

\subsubsection{Signal \& Idler}

\begin{figure}
	\begin{centering}
		\includegraphics[width=5in]{OPA800_tuning_examples/signal_and_idler_motortune.png}
		\caption{OPA800 (OPA2) signal and idler as measured by pyro. Data recorded 2015/10/15. Four quadrants are labeled with type and seed identification. Data taken with PyCMDS MOTORTUNE module.}
	\end{centering}
	\label{fig:opa800 signal and idler}
\end{figure}

\begin{figure}
	\begin{centering}
		\includegraphics[width=5in]{OPA800_tuning_examples/DFG_mixer_motortune.png}
		\caption{OPA800 (OPA2) DFG as measured by pyro. Data recorded 2015/10/16. Data taken with PyCMDS MOTORTUNE module.}
	\end{centering}
	\label{fig:opa800 DFG}
\end{figure}

\subsection{CoSet}

\pagebreak
\section{Diagrams}

The diagrams module provides specialized artists and tools for creating diagrams commonly used to describe CMDS experiments.

\printbibliography

\end{document}
